<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Loom Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Inter,
          "Helvetica Neue", Arial, sans-serif;
        background: radial-gradient(circle at top, #0b1220, #070b16 55%);
        color: #e2e8f0;
        min-height: 100vh;
      }

      .app-shell {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        backdrop-filter: blur(18px);
      }

      .app-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 18px 28px;
        border-bottom: 1px solid rgba(30, 41, 59, 0.6);
        background: rgba(10, 18, 34, 0.9);
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .logo-mark {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: linear-gradient(135deg, #3b82f6, #8b5cf6);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: #f8fafc;
        font-weight: 600;
        font-size: 18px;
        box-shadow: 0 12px 30px rgba(59, 130, 246, 0.25);
      }

      .brand-text h1 {
        font-size: 20px;
        font-weight: 600;
        color: #f8fafc;
        margin-bottom: 2px;
      }

      .brand-text p {
        font-size: 12px;
        color: #94a3b8;
      }

      .status-cluster {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 14px;
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.14);
        font-size: 13px;
        color: #dbedff;
      }

      .status-pill.muted {
        border-color: rgba(148, 163, 184, 0.25);
        background: rgba(148, 163, 184, 0.14);
        color: #cbd5f5;
      }

      .status-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #8aa4d0;
      }

      .status-value {
        font-size: 14px;
        font-weight: 600;
        color: #f8fafc;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #38bdf8;
        box-shadow: 0 0 12px rgba(59, 130, 246, 0.9);
        animation: pulse 2.6s ease-in-out infinite;
      }

      .status-dot.connected {
        background: #10b981;
        box-shadow: 0 0 12px rgba(16, 185, 129, 0.9);
      }

      .status-dot.disconnected {
        background: #f97316;
        box-shadow: 0 0 12px rgba(249, 115, 22, 0.85);
      }

      .status-dot.pending {
        background: #facc15;
        box-shadow: 0 0 12px rgba(250, 204, 21, 0.85);
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(0.85);
          opacity: 0.7;
        }
      }

      .dashboard-main {
        flex: 1;
        display: flex;
        gap: 20px;
        padding: 22px 28px 30px;
        overflow: hidden;
      }

      .insights-panel {
        width: 360px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        overflow-y: auto;
        padding-right: 6px;
      }

      .visual-panel {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 20px;
        overflow: hidden;
      }

      .card {
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.16);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 22px 48px rgba(4, 10, 24, 0.35);
      }

      .card-heading {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 14px;
        margin-bottom: 16px;
      }

      .card-heading h2 {
        font-size: 16px;
        font-weight: 600;
        color: #f8fafc;
      }

      .card-subtitle {
        font-size: 12px;
        color: #94a3b8;
        margin-top: 4px;
      }

      .metric-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 16px;
      }

      .metric {
        display: flex;
        flex-direction: column;
        gap: 6px;
        background: rgba(30, 41, 59, 0.84);
        border: 1px solid rgba(59, 130, 246, 0.1);
        border-radius: 12px;
        padding: 14px 16px;
      }

      .metric-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: #7f8cb2;
      }

      .metric-value {
        font-size: 22px;
        font-weight: 600;
        color: #f8fafc;
      }

      .filters-card label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 12px;
        color: #94a3b8;
        margin-bottom: 12px;
      }

      .filter-input {
        background: rgba(9, 14, 26, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.22);
        border-radius: 10px;
        padding: 10px 12px;
        color: #f8fafc;
        font-size: 13px;
        transition: border 0.18s ease, box-shadow 0.18s ease;
      }

      .filter-input:focus {
        outline: none;
        border-color: rgba(59, 130, 246, 0.7);
        box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.3);
      }

      .button-row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 8px 14px;
        border-radius: 10px;
        border: 1px solid rgba(59, 130, 246, 0.55);
        background: rgba(59, 130, 246, 0.18);
        color: #e0ecff;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn:hover {
        background: rgba(59, 130, 246, 0.26);
      }

      .btn.active {
        background: #3b82f6;
        border-color: #3b82f6;
        color: #0f172a;
      }

      .btn.btn-secondary {
        border-color: rgba(148, 163, 184, 0.35);
        background: rgba(148, 163, 184, 0.16);
        color: #e2e8f0;
      }

      .btn.btn-secondary:hover {
        background: rgba(148, 163, 184, 0.24);
      }

      .events-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
        max-height: 420px;
        overflow-y: auto;
        padding-right: 6px;
      }

      .event-item {
        display: flex;
        flex-direction: column;
        gap: 10px;
        background: rgba(11, 18, 32, 0.9);
        border: 1px solid rgba(59, 130, 246, 0.08);
        border-radius: 12px;
        padding: 14px 16px;
      }

      .event-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .event-topic {
        font-family: "JetBrains Mono", "Courier New", monospace;
        font-size: 13px;
        color: #38bdf8;
      }

      .event-time {
        font-size: 11px;
        color: #7f8cb2;
      }

      .event-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 11px;
        color: #dbe8ff;
      }

      .event-type {
        display: inline-flex;
        align-items: center;
        padding: 2px 10px;
        border-radius: 999px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        font-weight: 600;
        background: rgba(59, 130, 246, 0.16);
        color: #60a5fa;
      }

      .event-type-event_delivered {
        background: rgba(16, 185, 129, 0.16);
        color: #6ee7b7;
      }

      .event-type-agent_registered {
        background: rgba(139, 92, 246, 0.16);
        color: #c4b5fd;
      }

      .event-type-tool_invoked {
        background: rgba(245, 158, 11, 0.16);
        color: #fbbf24;
      }

      .event-meta-field {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 6px;
        border-radius: 8px;
        background: rgba(30, 41, 59, 0.6);
      }

      .meta-label {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: #7f8cb2;
      }

      .event-payload {
        font-family: "JetBrains Mono", "Courier New", monospace;
        font-size: 12px;
        color: #e2e8f0;
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(59, 130, 246, 0.1);
        border-radius: 10px;
        padding: 10px 12px;
        white-space: pre-wrap;
        overflow-x: auto;
      }

      .empty-state {
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        min-height: 140px;
        border: 1px dashed rgba(148, 163, 184, 0.35);
        border-radius: 14px;
        color: #8293b7;
        font-size: 13px;
        background: rgba(15, 23, 42, 0.5);
      }

      .topology-list {
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 12px;
        max-height: 190px;
        overflow-y: auto;
        padding-right: 4px;
      }

      .topology-item {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(11, 18, 32, 0.78);
      }

      .agent-name {
        font-weight: 600;
        color: #f8fafc;
      }

      .agent-topics {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .topic-chip {
        padding: 4px 8px;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.18);
        border: 1px solid rgba(59, 130, 246, 0.24);
        color: #9cc4ff;
        font-size: 11px;
      }

      .more-indicator {
        margin-top: 10px;
        font-size: 12px;
        color: #94a3b8;
      }

      .flow-card {
        display: flex;
        flex-direction: column;
        gap: 16px;
        flex: 1;
        min-height: 0;
      }

      .flow-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
        flex-wrap: wrap;
      }

      .flow-summary {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: flex-end;
      }

      .summary-chip {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        padding: 8px 12px;
        background: rgba(15, 23, 42, 0.82);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 12px;
        min-width: 76px;
      }

      .summary-label {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: #7f8cb2;
      }

      .summary-value {
        font-size: 16px;
        font-weight: 600;
        color: #f8fafc;
        margin-top: 4px;
      }

      .flow-canvas {
        position: relative;
        flex: 1;
        min-height: 430px;
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(11, 18, 32, 0.76);
        overflow: hidden;
      }

      .flow-canvas svg {
        width: 100%;
        height: 100%;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        font-size: 11px;
        color: #94a3b8;
        padding-top: 12px;
        border-top: 1px solid rgba(148, 163, 184, 0.16);
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .legend-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-flex;
      }

      .legend-dot.agent,
      .node-agent circle {
        background: #3b82f6;
        fill: #3b82f6;
      }

      .legend-dot.eventbus,
      .node-eventbus circle {
        background: #8b5cf6;
        fill: #8b5cf6;
      }

      .legend-dot.router,
      .node-router circle {
        background: #f59e0b;
        fill: #f59e0b;
      }

      .legend-dot.llm,
      .node-llm circle {
        background: #10b981;
        fill: #10b981;
      }

      .legend-dot.tool,
      .node-tool circle {
        background: #ef4444;
        fill: #ef4444;
      }

      .legend-dot.storage,
      .node-storage circle {
        background: #06b6d4;
        fill: #06b6d4;
      }

      .node circle {
        stroke: rgba(148, 163, 184, 0.28);
        stroke-width: 2px;
      }

      .node-label {
        fill: #e2e8f0;
        font-weight: 600;
        font-size: 11px;
        pointer-events: none;
      }

      .node-badge circle {
        fill: rgba(15, 23, 42, 0.9);
        stroke: rgba(148, 163, 184, 0.2);
      }

      .badge-text {
        font-size: 10px;
        fill: #dbe8ff;
        font-weight: 600;
      }

      .link {
        stroke: rgba(94, 109, 155, 0.65);
        stroke-width: 1.6px;
        fill: none;
      }

      .link.active {
        stroke: #3b82f6;
        stroke-width: 2.2px;
      }

      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      ::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.4);
      }

      ::-webkit-scrollbar-thumb {
        background: rgba(59, 130, 246, 0.35);
        border-radius: 999px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: rgba(59, 130, 246, 0.55);
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <script type="text/x-template" id="app-template">
      <div class="app-shell">
        <header class="app-header">
          <div class="brand">
            <span class="logo-mark">â—‰</span>
            <div class="brand-text">
              <h1>Loom Dashboard</h1>
              <p>Real-time agent observability</p>
            </div>
          </div>
          <div class="status-cluster">
            <div
              class="status-pill"
              :class="{
                muted: connectionStatus !== 'Connected'
              }"
            >
              <span
                :class="[
                  'status-dot',
                  connectionStatus === 'Connected'
                    ? 'connected'
                    : connectionStatus === 'Connecting...'
                    ? 'pending'
                    : 'disconnected'
                ]"
              ></span>
              <span>{{ connectionStatus }}</span>
            </div>
            <div class="status-pill muted">
              <div class="status-label">Events seen</div>
              <div class="status-value">{{ eventCount }}</div>
            </div>
          </div>
        </header>

        <main class="dashboard-main">
          <aside class="insights-panel">
            <section class="card metrics-card">
              <div class="card-heading">
                <div>
                  <h2>At a glance</h2>
                  <p class="card-subtitle">
                    Flow updated {{ formattedFlowUpdatedAt }}
                  </p>
                </div>
              </div>
              <div class="metric-grid">
                <div class="metric">
                  <span class="metric-label">Events / sec</span>
                  <span class="metric-value"
                    >{{ formatNumber(metrics.events_per_sec) }}</span
                  >
                </div>
                <div class="metric">
                  <span class="metric-label">Active agents</span>
                  <span class="metric-value"
                    >{{ formatNumber(metrics.active_agents) }}</span
                  >
                </div>
                <div class="metric">
                  <span class="metric-label">Subscriptions</span>
                  <span class="metric-value"
                    >{{ formatNumber(metrics.active_subscriptions) }}</span
                  >
                </div>
                <div class="metric">
                  <span class="metric-label">Tool calls / sec</span>
                  <span class="metric-value"
                    >{{ formatNumber(metrics.tool_invocations_per_sec) }}</span
                  >
                </div>
              </div>
            </section>

            <section class="card filters-card">
              <div class="card-heading">
                <h2>Filters</h2>
              </div>
              <label>
                Thread
                <input
                  class="filter-input"
                  type="text"
                  v-model="filters.threadId"
                  placeholder="thread-id"
                />
              </label>
              <label>
                Topic
                <input
                  class="filter-input"
                  type="text"
                  v-model="filters.topic"
                  placeholder="agent.topic"
                />
              </label>
              <label>
                Sender
                <input
                  class="filter-input"
                  type="text"
                  v-model="filters.sender"
                  placeholder="agent-id"
                />
              </label>
            </section>

            <section class="card events-card">
              <div class="card-heading">
                <div>
                  <h2>Event stream</h2>
                  <p class="card-subtitle">
                    {{ filteredEvents.length }} matching events
                  </p>
                </div>
                <div class="button-row">
                  <button
                    class="btn"
                    :class="{ active: autoScroll }"
                    @click="toggleAutoScroll"
                  >
                    {{ autoScroll ? "Auto-scroll" : "Paused" }}
                  </button>
                  <button class="btn btn-secondary" @click="clearEvents">
                    Clear
                  </button>
                </div>
              </div>
              <div class="events-list" ref="eventsListRef">
                <div v-if="filteredEvents.length === 0" class="empty-state">
                  Waiting for events...
                </div>
                <article
                  v-for="event in filteredEvents"
                  :key="event.event_id"
                  class="event-item"
                >
                  <header class="event-header">
                    <span class="event-topic">{{ event.topic }}</span>
                    <span class="event-time">{{
                      formatTime(event.timestamp)
                    }}</span>
                  </header>
                  <div class="event-meta">
                    <span
                      class="event-type"
                      :class="`event-type-${event.event_type}`"
                    >
                      {{ event.event_type }}
                    </span>
                    <span v-if="event.sender" class="event-meta-field">
                      <span class="meta-label">sender</span>
                      <span>{{ event.sender }}</span>
                    </span>
                    <span v-if="event.thread_id" class="event-meta-field">
                      <span class="meta-label">thread</span>
                      <span>{{ event.thread_id }}</span>
                    </span>
                    <span v-if="event.correlation_id" class="event-meta-field">
                      <span class="meta-label">corr</span>
                      <span>{{ event.correlation_id.slice(0, 8) }}...</span>
                    </span>
                  </div>
                  <pre class="event-payload">{{ event.payload_preview }}</pre>
                </article>
              </div>
            </section>
          </aside>

          <section class="visual-panel">
            <section class="card topology-card">
              <div class="card-heading">
                <div>
                  <h2>Agent roster</h2>
                  <p class="card-subtitle">
                    Updated
                    {{
                      topology.timestamp ? formatTime(topology.timestamp) : "n/a"
                    }}
                  </p>
                </div>
                <span class="summary-chip">
                  <span class="summary-label">Agents</span>
                  <span class="summary-value">{{ topology.agents.length }}</span>
                </span>
              </div>
              <div v-if="topologyMissing" class="empty-state">
                No agents registered yet.
              </div>
              <template v-else>
                <ul class="topology-list">
                  <li
                    v-for="agent in topologyPreview"
                    :key="agent.id"
                    class="topology-item"
                  >
                    <div class="agent-name">{{ agent.id }}</div>
                    <div class="agent-topics">
                      <span
                        v-for="topic in agent.topics.slice(0, 3)"
                        :key="`${agent.id}-${topic}`"
                        class="topic-chip"
                      >
                        {{ topic }}
                      </span>
                    </div>
                  </li>
                </ul>
                <p
                  v-if="topology.agents.length > topologyPreview.length"
                  class="more-indicator"
                >
                  +{{ topology.agents.length - topologyPreview.length }} more
                  agents
                </p>
              </template>
            </section>

            <section class="card flow-card">
              <div class="flow-header">
                <div>
                  <h2>Event flow</h2>
                  <p class="card-subtitle">
                    Last updated {{ formattedFlowUpdatedAt }}
                  </p>
                </div>
                <div class="flow-summary">
                  <div class="summary-chip">
                    <span class="summary-label">Nodes</span>
                    <span class="summary-value">{{ flowSummary.nodes }}</span>
                  </div>
                  <div class="summary-chip">
                    <span class="summary-label">Flows</span>
                    <span class="summary-value">{{ flowSummary.flows }}</span>
                  </div>
                  <div class="summary-chip">
                    <span class="summary-label">Active</span>
                    <span class="summary-value">{{ flowSummary.activeLinks }}</span>
                  </div>
                  <div class="summary-chip">
                    <span class="summary-label">Topics</span>
                    <span class="summary-value">{{ flowSummary.topics }}</span>
                  </div>
                </div>
              </div>
              <div class="flow-canvas" ref="flowCanvas">
                <div
                  v-if="flowSummary.nodes === 0 || flowSummary.flows === 0"
                  class="empty-state"
                >
                  Waiting for flow data...
                </div>
              </div>
              <footer class="legend">
                <span class="legend-item"
                  ><span class="legend-dot agent"></span>Agent</span
                >
                <span class="legend-item"
                  ><span class="legend-dot eventbus"></span>EventBus</span
                >
                <span class="legend-item"
                  ><span class="legend-dot router"></span>Router</span
                >
                <span class="legend-item"
                  ><span class="legend-dot llm"></span>LLM</span
                >
                <span class="legend-item"
                  ><span class="legend-dot tool"></span>Tool</span
                >
                <span class="legend-item"
                  ><span class="legend-dot storage"></span>Storage</span
                >
              </footer>
            </section>
          </section>
        </main>
      </div>
    </script>

    <script type="module">
      import {
        createApp,
        ref,
        reactive,
        computed,
        watch,
        onMounted,
        onBeforeUnmount,
        nextTick,
      } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";

      createApp({
        template: "#app-template",
        setup() {
          const connectionStatus = ref("Connecting...");
          const eventCount = ref(0);
          const autoScroll = ref(true);
          const allEvents = ref([]);
          const filters = reactive({
            threadId: "",
            topic: "",
            sender: "",
          });
          const metrics = reactive({
            events_per_sec: 0,
            active_agents: 0,
            active_subscriptions: 0,
            tool_invocations_per_sec: 0,
          });
          const topology = ref({
            agents: [],
            edges: [],
            timestamp: null,
          });
          const flowData = ref({
            nodes: [],
            flows: [],
            timestamp: null,
          });
          const flowUpdatedAt = ref(null);

          const flowCanvas = ref(null);
          const eventsListRef = ref(null);

          let eventSource = null;
          let reconnectTimer = null;
          const intervalHandles = [];
          let resizeHandler = null;

          let svg = null;
          let linkGroup = null;
          let nodeGroup = null;
          let simulation = null;

          const filteredEvents = computed(() =>
            allEvents.value.filter((evt) => {
              if (
                filters.threadId &&
                !(evt.thread_id || "").includes(filters.threadId)
              ) {
                return false;
              }
              if (
                filters.topic &&
                !(evt.topic || "").includes(filters.topic)
              ) {
                return false;
              }
              if (
                filters.sender &&
                !(evt.sender || "").includes(filters.sender)
              ) {
                return false;
              }
              return true;
            })
          );

          const topologyPreview = computed(() =>
            topology.value.agents.slice(0, 6)
          );

          const topologyMissing = computed(
            () => topology.value.agents.length === 0
          );

          const flowSummary = computed(() => {
            const nodes = flowData.value.nodes.length;
            const flows = flowData.value.flows.length;
            const topics = new Set(
              flowData.value.flows.map((f) => f.topic)
            ).size;
            const activeLinks = flowData.value.flows.filter(
              (f) => Date.now() - f.last_event_ms < 4_000
            ).length;
            return {
              nodes,
              flows,
              topics,
              activeLinks,
            };
          });

          const formattedFlowUpdatedAt = computed(() => {
            if (!flowUpdatedAt.value) {
              return "n/a";
            }
            return new Date(flowUpdatedAt.value).toLocaleTimeString();
          });

          watch(filteredEvents, () => {
            nextTick(() => {
              if (autoScroll.value && eventsListRef.value) {
                eventsListRef.value.scrollTop =
                  eventsListRef.value.scrollHeight;
              }
            });
          });

          watch(
            flowData,
            () => {
              nextTick(renderFlowGraph);
            },
            { deep: true }
          );

          function scheduleReconnect() {
            if (reconnectTimer) {
              return;
            }
            reconnectTimer = setTimeout(() => {
              reconnectTimer = null;
              connectEventStream();
            }, 3000);
          }

          function connectEventStream() {
            if (eventSource) {
              eventSource.close();
              eventSource = null;
            }

            const source = new EventSource("/api/events/stream");
            eventSource = source;
            connectionStatus.value = "Connecting...";

            source.onopen = () => {
              connectionStatus.value = "Connected";
              if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
              }
            };

            source.onmessage = (event) => {
              try {
                const payload = JSON.parse(event.data);
                appendEvent(payload);
              } catch (err) {
                console.error("Failed to parse SSE payload", err);
              }
            };

            source.onerror = () => {
              connectionStatus.value = "Disconnected";
              if (eventSource) {
                eventSource.close();
                eventSource = null;
              }
              scheduleReconnect();
            };
          }

          function appendEvent(evt) {
            allEvents.value.push(evt);
            eventCount.value += 1;

            if (allEvents.value.length > 500) {
              allEvents.value.splice(0, allEvents.value.length - 500);
            }
          }

          function toggleAutoScroll() {
            autoScroll.value = !autoScroll.value;
          }

          function clearEvents() {
            allEvents.value = [];
            eventCount.value = 0;
          }

          async function loadTopology() {
            try {
              const response = await fetch("/api/topology");
              const snapshot = await response.json();
              const agents = (snapshot.agents || []).map((agent) => ({
                ...agent,
                topics: agent.topics || [],
                capabilities: agent.capabilities || [],
              }));
              topology.value = {
                ...snapshot,
                agents,
              };
              metrics.active_agents = agents.length;
            } catch (err) {
              console.error("Failed to load topology", err);
            }
          }

          async function loadMetrics() {
            try {
              const response = await fetch("/api/metrics");
              const snapshot = await response.json();
              Object.assign(metrics, snapshot);
            } catch (err) {
              console.error("Failed to load metrics", err);
            }
          }

          async function loadFlow() {
            try {
              const response = await fetch("/api/flow");
              const snapshot = await response.json();
              flowData.value = {
                ...snapshot,
                nodes: snapshot.nodes || [],
                flows: snapshot.flows || [],
              };
              flowUpdatedAt.value = Date.now();
            } catch (err) {
              console.error("Failed to load flow graph", err);
            }
          }

          function tearDownFlowGraph() {
            if (svg) {
              svg.remove();
              svg = null;
              linkGroup = null;
              nodeGroup = null;
              simulation = null;
            }
          }

          function renderFlowGraph() {
            const container = flowCanvas.value;
            if (!container) {
              return;
            }

            const hasData =
              flowSummary.value.nodes > 0 && flowData.value.flows.length > 0;
            if (!hasData) {
              tearDownFlowGraph();
              return;
            }

            const width = container.clientWidth;
            const height = container.clientHeight || 480;

            if (!width || !height) {
              return;
            }

            if (!svg) {
              svg = d3
                .select(container)
                .append("svg")
                .attr("class", "flow-svg")
                .attr("width", width)
                .attr("height", height);

              const defs = svg.append("defs");
              defs
                .append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 20)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#475569");

              linkGroup = svg.append("g").attr("class", "links");
              nodeGroup = svg.append("g").attr("class", "nodes");

              simulation = d3
                .forceSimulation()
                .force("link", d3.forceLink().id((d) => d.id).distance(140))
                .force("charge", d3.forceManyBody().strength(-360))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(42));
            } else {
              svg.attr("width", width).attr("height", height);
              simulation.force("center", d3.forceCenter(width / 2, height / 2));
            }

            const nodes = flowData.value.nodes.map((node) => ({
              ...node,
              topics: Array.isArray(node.topics)
                ? node.topics
                : Array.from(node.topics || []),
            }));

            const links = flowData.value.flows.map((flow) => ({
              ...flow,
              active: Date.now() - flow.last_event_ms < 4_000,
            }));

            const linkSelection = linkGroup
              .selectAll(".link")
              .data(links, (d) => `${d.source}-${d.target}-${d.topic}`);

            linkSelection.exit().remove();

            const linkEnter = linkSelection
              .enter()
              .append("path")
              .attr("class", "link")
              .attr("marker-end", "url(#arrowhead)");

            linkSelection
              .merge(linkEnter)
              .classed("active", (d) => d.active)
              .attr("stroke-dasharray", (d) => (d.active ? "6,4" : null));

            const nodeSelection = nodeGroup
              .selectAll(".node")
              .data(nodes, (d) => d.id);

            nodeSelection.exit().remove();

            const nodeEnter = nodeSelection
              .enter()
              .append("g")
              .attr("class", (d) => `node node-${d.node_type}`)
              .call(
                d3
                  .drag()
                  .on("start", (event, d) => {
                    if (!event.active) {
                      simulation.alphaTarget(0.3).restart();
                    }
                    d.fx = d.x;
                    d.fy = d.y;
                  })
                  .on("drag", (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                  })
                  .on("end", (event, d) => {
                    if (!event.active) {
                      simulation.alphaTarget(0);
                    }
                    d.fx = null;
                    d.fy = null;
                  })
              );

            nodeEnter.append("circle").attr("r", 24);

            nodeEnter
              .append("text")
              .attr("class", "node-label")
              .attr("dy", 36)
              .text((d) => d.id);

            const badge = nodeEnter
              .append("g")
              .attr("class", "node-badge")
              .attr("transform", "translate(14,-16)");

            badge.append("circle").attr("r", 11);

            badge
              .append("text")
              .attr("class", "badge-text")
              .attr("dy", 4)
              .attr("text-anchor", "middle")
              .text((d) => (d.event_count > 99 ? "99+" : d.event_count));

            nodeSelection
              .merge(nodeEnter)
              .select(".badge-text")
              .text((d) => (d.event_count > 99 ? "99+" : d.event_count));

            simulation.nodes(nodes);
            simulation.force("link").links(links);

            simulation.on("tick", () => {
              linkGroup.selectAll(".link").attr("d", (d) => {
                const source =
                  typeof d.source === "object"
                    ? d.source
                    : nodes.find((n) => n.id === d.source);
                const target =
                  typeof d.target === "object"
                    ? d.target
                    : nodes.find((n) => n.id === d.target);
                if (!source || !target) {
                  return "";
                }
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dr = Math.sqrt(dx * dx + dy * dy);
                return `M${source.x},${source.y}A${dr},${dr} 0 0,1 ${target.x},${target.y}`;
              });

              nodeGroup
                .selectAll(".node")
                .attr("transform", (d) => `translate(${d.x},${d.y})`);
            });

            simulation.alpha(0.25).restart();
          }

          function formatNumber(value) {
            if (value === undefined || value === null || Number.isNaN(value)) {
              return "0";
            }
            return new Intl.NumberFormat("en-US", {
              maximumFractionDigits: value < 10 ? 2 : 0,
            }).format(value);
          }

          function formatTime(timestamp) {
            return new Date(timestamp).toLocaleTimeString();
          }

          onMounted(() => {
            connectEventStream();
            loadTopology();
            loadMetrics();
            loadFlow();

            intervalHandles.push(setInterval(loadTopology, 10_000));
            intervalHandles.push(setInterval(loadMetrics, 2_000));
            intervalHandles.push(setInterval(loadFlow, 2_500));

            resizeHandler = () => renderFlowGraph();
            window.addEventListener("resize", resizeHandler);
          });

          onBeforeUnmount(() => {
            if (eventSource) {
              eventSource.close();
              eventSource = null;
            }
            if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
            }
            intervalHandles.forEach((handle) => clearInterval(handle));
            if (resizeHandler) {
              window.removeEventListener("resize", resizeHandler);
              resizeHandler = null;
            }
            tearDownFlowGraph();
          });

          return {
            autoScroll,
            clearEvents,
            connectionStatus,
            eventCount,
            eventsListRef,
            filteredEvents,
            filters,
            flowCanvas,
            flowSummary,
            formattedFlowUpdatedAt,
            formatNumber,
            formatTime,
            metrics,
            toggleAutoScroll,
            topology,
            topologyPreview,
            topologyMissing,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
