"""Executor Agent - Trade Execution

Executes trading plans generated by the planner agent.
Connects to OKX via WebSocket for order placement.
"""

import asyncio
import json
import hmac
import base64
import time
import os
from datetime import datetime, timezone
from typing import Optional, Dict, Any
from dataclasses import dataclass

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False
    print("[executor] WARNING: aiohttp not available, WebSocket connection disabled")

from opentelemetry import trace
from loom import Agent, load_project_config

# Get tracer for business logic spans
tracer = trace.get_tracer(__name__)

# Default symbol
SYMBOL = "BTC"

# Global executor instance for event handler access
EXECUTOR_INSTANCE: Optional["TradeExecutor"] = None


# Simple file logger to capture early-exit issues under orchestrator
_LOG_FH = None

def _init_file_logger():
    global _LOG_FH
    try:
        base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        logs_dir = os.path.join(base_dir, "logs")
        os.makedirs(logs_dir, exist_ok=True)
        _LOG_FH = open(os.path.join(logs_dir, "executor-agent.log"), "a", buffering=1)
    except Exception:
        _LOG_FH = None


def _log(msg: str):
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{ts}] {msg}\n"
    try:
        print(f"[executor] {msg}")
    except Exception:
        pass
    if _LOG_FH:
        try:
            _LOG_FH.write(line)
        except Exception:
            pass


@dataclass
class ExecutorConfig:
    """Executor configuration."""

    api_key: str
    secret_key: str
    passphrase: str
    use_demo: bool = True
    min_order_usdt: float = 10.0     # Minimum order size in USDT
    max_order_usdt: float = 100.0    # Maximum order size in USDT
    enable_trading: bool = False      # Safety switch - must be explicitly enabled

    @property
    def ws_url(self) -> str:
        """Get WebSocket URL based on trading mode."""
        if self.use_demo:
            return "wss://wspap.okx.com:8443/ws/v5/private?brokerId=9999"
        else:
            return "wss://ws.okx.com:8443/ws/v5/private"


class OKXTradingClient:
    """OKX WebSocket client for trade execution."""

    def __init__(self, config: ExecutorConfig):
        self.config = config
        self.ws: Optional[aiohttp.ClientWebSocketResponse] = None
        self.session: Optional[aiohttp.ClientSession] = None
        self._authenticated = False
        self._request_id = 0
        self._pending_requests: Dict[str, asyncio.Future] = {}

    def _generate_signature(self, timestamp: str, method: str, request_path: str) -> str:
        """Generate OKX API signature."""
        message = timestamp + method + request_path
        mac = hmac.new(
            self.config.secret_key.encode('utf-8'),
            message.encode('utf-8'),
            digestmod='sha256'
        )
        return base64.b64encode(mac.digest()).decode('utf-8')

    async def connect(self) -> bool:
        """Connect to OKX WebSocket and authenticate."""
        if not AIOHTTP_AVAILABLE:
            print("[executor-okx] aiohttp not available")
            return False

        try:
            self.session = aiohttp.ClientSession()
            self.ws = await self.session.ws_connect(
                self.config.ws_url,
                timeout=aiohttp.ClientTimeout(total=30)
            )
            print(f"[executor-okx] WebSocket connected to {self.config.ws_url}")

            # Authenticate
            timestamp = str(int(datetime.now(timezone.utc).timestamp()))
            sign = self._generate_signature(timestamp, 'GET', '/users/self/verify')

            login_msg = {
                "op": "login",
                "args": [{
                    "apiKey": self.config.api_key,
                    "passphrase": self.config.passphrase,
                    "timestamp": timestamp,
                    "sign": sign
                }]
            }

            await self.ws.send_json(login_msg)

            # Wait for login response
            async for msg in self.ws:
                if msg.type == aiohttp.WSMsgType.TEXT:
                    data = json.loads(msg.data)
                    if data.get('event') == 'login':
                        if data.get('code') == '0':
                            self._authenticated = True
                            _log("OKX: Authentication successful")

                            # Subscribe to private order updates (helps as fallback ack)
                            try:
                                sub_msg = {
                                    "op": "subscribe",
                                    "args": [
                                        {"channel": "orders", "instType": "SPOT"},
                                        {"channel": "orders", "instType": "SWAP"},
                                    ],
                                }
                                await self.ws.send_json(sub_msg)
                                _log("OKX: Subscribed to private orders channels (SPOT, SWAP)")
                            except Exception as e:
                                _log(f"OKX: Failed to subscribe orders channel: {e}")

                            # Start message handler after login
                            asyncio.create_task(self._message_handler())
                            return True
                        else:
                            _log(f"OKX: Authentication failed: {data.get('msg')}")
                            return False
                elif msg.type == aiohttp.WSMsgType.ERROR:
                    print(f"[executor-okx] WebSocket error during auth: {self.ws.exception()}")
                    return False

            return False

        except Exception as e:
            _log(f"OKX: Connection error: {e}")
            if self.session:
                await self.session.close()
            return False

    async def _message_handler(self):
        """Handle incoming WebSocket messages."""
        try:
            async for msg in self.ws:
                if msg.type == aiohttp.WSMsgType.TEXT:
                    data = json.loads(msg.data)
                    # Debug log abbreviated incoming messages
                    try:
                        kind = data.get('event') or data.get('op') or data.get('arg', {}).get('channel')
                        _log(f"OKX WS recv kind={kind}")
                    except Exception:
                        pass

                    # Handle order responses (immediate ack from op=order)
                    # OKX returns {"id":"xxx","op":"order","data":[{...}],"code":"0","msg":""}
                    if data.get('op') == 'order':
                        request_id = data.get('id')
                        if request_id and request_id in self._pending_requests:
                            future = self._pending_requests.pop(request_id)
                            if data.get('code') == '0':
                                future.set_result(data)
                                _log(f"OKX: Order ack received for id={request_id}")
                            else:
                                # Order failed
                                error_data = data.get('data', [{}])[0]
                                error_msg = error_data.get('sMsg', data.get('msg', 'Order failed'))
                                error_code = error_data.get('sCode', data.get('code'))
                                _log(f"OKX: Order failed code={error_code} msg={error_msg}")
                                future.set_exception(Exception(f"{error_code}: {error_msg}"))

                    # Handle error events
                    elif data.get('event') == 'error':
                        error_msg = data.get('msg', 'Unknown error')
                        error_code = data.get('code', 'unknown')
                        _log(f"OKX: Error event code={error_code} msg={error_msg} data={data}")
                        request_id = data.get('id')
                        if request_id and request_id in self._pending_requests:
                            future = self._pending_requests.pop(request_id)
                            future.set_exception(Exception(f"{error_code}: {error_msg}"))

                    # Handle orders channel updates as fallback ack (match by clOrdId)
                    elif data.get('arg', {}).get('channel') == 'orders' and data.get('data'):
                        orders = data.get('data', [])
                        for od in orders:
                            cl_id = od.get('clOrdId')
                            # Try to match as a backup confirmation method
                            if cl_id:
                                _log(f"OKX: Orders channel update for clOrdId={cl_id} state={od.get('state')}")

                elif msg.type == aiohttp.WSMsgType.ERROR:
                    _log(f"OKX: WebSocket error: {self.ws.exception()}")
                    break

                elif msg.type == aiohttp.WSMsgType.CLOSED:
                    _log("OKX: WebSocket closed")
                    break

        except asyncio.CancelledError:
            _log("OKX: Message handler cancelled")
        except Exception as e:
            _log(f"OKX: Message handler error: {e}")

    async def place_market_order(
        self,
        inst_id: str,
        side: str,  # "buy" or "sell"
        size_usdt: float,  # Order size in USDT
        trade_mode: str = "cash"  # "cash" for spot, "cross" for margin
    ) -> Dict[str, Any]:
        """Place a market order.

        Args:
            inst_id: Instrument ID (e.g., "BTC-USDT")
            side: "buy" or "sell"
            size_usdt: Order size in USDT (quote currency)
            trade_mode: Trading mode ("cash", "cross", "isolated")

        Returns:
            Order response dict
        """
        if not self._authenticated:
            raise Exception("Not authenticated")

        self._request_id += 1
        # OKX requires id field, use timestamp-based unique ID
        request_id = str(int(time.time()*1000) + self._request_id)
        # clOrdId: alphanumeric, max 32 chars
        cl_ord_id = f"loom{int(time.time()*1000)}"

        order_msg = {
            "id": request_id,  # Required by OKX
            "op": "order",
            "args": [{
                "instId": inst_id,
                "tdMode": trade_mode,
                "side": side.lower(),
                "ordType": "market",
                "sz": str(size_usdt),
                "clOrdId": cl_ord_id,
                "tgtCcy": "quote_ccy"  # Size in USDT (quote currency)
            }]
        }

        # Create future for response
        future = asyncio.Future()
        self._pending_requests[request_id] = future

        # Send order
        await self.ws.send_json(order_msg)
        _log(f"OKX: Sent {side.upper()} order: {size_usdt} USDT of {inst_id}")

        try:
            # Wait for response (with timeout)
            response = await asyncio.wait_for(future, timeout=20.0)
            return response
        except asyncio.TimeoutError:
            self._pending_requests.pop(request_id, None)
            raise Exception("Order timeout")

    async def close(self):
        """Close WebSocket connection."""
        self._authenticated = False
        if self.ws:
            await self.ws.close()
        if self.session:
            await self.session.close()
        print("[executor-okx] WebSocket closed")


class TradeExecutor:
    """Trade execution engine."""

    def __init__(self, config: ExecutorConfig):
        self.config = config
        self.client: Optional[OKXTradingClient] = None
        self._connected = False

    async def initialize(self) -> bool:
        """Initialize trading client."""
        if not self.config.enable_trading:
            print("[executor] âš ï¸  Trading is DISABLED (safety switch)")
            print("[executor] Set enable_trading=true in config to enable")
            return False

        print("[executor] Initializing OKX trading client...")
        self.client = OKXTradingClient(self.config)
        self._connected = await self.client.connect()

        if self._connected:
            print("[executor] âœ… Trading client ready")
        else:
            print("[executor] âŒ Failed to connect to OKX")

        return self._connected

    async def execute_plan(self, plan: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a trading plan.

        Args:
            plan: Trading plan from planner agent

        Returns:
            Execution result
        """
        with tracer.start_as_current_span(
            "executor.execute_plan",
            attributes={
                "executor.symbol": plan.get("symbol", "unknown"),
                "executor.action": plan.get("action", "unknown"),
                "executor.confidence": plan.get("confidence", 0.0),
            },
        ) as span:
            action = plan.get("action", "HOLD")
            symbol = plan.get("symbol", SYMBOL)
            confidence = plan.get("confidence", 0.0)

            result = {
                "symbol": symbol,
                "plan_action": action,
                "plan_confidence": confidence,
                "executed": False,
                "execution_time_ms": int(time.time() * 1000),
            }

            # Check if trading is enabled
            if not self.config.enable_trading:
                result["status"] = "skipped"
                result["message"] = "Trading disabled (safety switch)"
                print(f"[executor] SIMULATED: {action} {symbol} (confidence: {confidence:.2%})")
                span.set_attribute("executor.status", "simulated")
                return result

            # Check if connected
            if not self._connected or not self.client:
                result["status"] = "error"
                result["message"] = "Not connected to exchange"
                print(f"[executor] ERROR: Not connected to OKX")
                span.set_attribute("executor.status", "error")
                return result

            # Execute based on action
            try:
                if action == "HOLD":
                    result["status"] = "hold"
                    result["message"] = "No action required"
                    print(f"[executor] HOLD {symbol} - No action")
                    span.set_attribute("executor.status", "hold")

                elif action in ["BUY", "SELL"]:
                    # Calculate order size based on confidence (in USDT)
                    # Higher confidence = larger position size
                    order_size_usdt = self._calculate_order_size(confidence)

                    inst_id = f"{symbol}-USDT"
                    side = "buy" if action == "BUY" else "sell"

                    # Place order
                    order_response = await self.client.place_market_order(
                        inst_id=inst_id,
                        side=side,
                        size_usdt=order_size_usdt,
                        trade_mode="cash"  # Spot trading
                    )

                    # Parse response
                    if order_response.get("code") == "0":
                        order_data = order_response.get("data", [{}])[0]
                        result["executed"] = True
                        result["status"] = "success"
                        result["order_id"] = order_data.get("ordId")
                        result["order_size_usdt"] = order_size_usdt
                        result["message"] = f"Order placed: {side.upper()} {order_size_usdt} USDT of {inst_id}"

                        print(f"[executor] âœ… EXECUTED: {side.upper()} {order_size_usdt} USDT of {inst_id}")
                        print(f"[executor]    Order ID: {result['order_id']}")

                        span.set_attribute("executor.status", "success")
                        span.set_attribute("executor.order_id", result["order_id"])
                        span.set_attribute("executor.order_size_usdt", order_size_usdt)
                    else:
                        result["status"] = "error"
                        result["message"] = order_response.get("msg", "Order failed")
                        print(f"[executor] âŒ ORDER FAILED: {result['message']}")
                        span.set_attribute("executor.status", "error")

                else:
                    result["status"] = "error"
                    result["message"] = f"Unknown action: {action}"
                    span.set_attribute("executor.status", "error")

            except Exception as e:
                result["status"] = "error"
                result["message"] = str(e)
                print(f"[executor] âŒ EXECUTION ERROR: {e}")
                span.set_attribute("executor.status", "error")
                span.record_exception(e)

            return result

    def _calculate_order_size(self, confidence: float) -> float:
        """Calculate order size based on confidence level.

        Higher confidence = larger position size (within limits).
        Returns size in USDT.
        """
        # Scale order size: 50% confidence = min size, 100% confidence = max size
        size_range = self.config.max_order_usdt - self.config.min_order_usdt
        confidence_factor = max(0.0, min(1.0, (confidence - 0.5) * 2))  # Map 0.5-1.0 to 0-1

        order_size = self.config.min_order_usdt + (size_range * confidence_factor)
        return round(order_size, 2)  # Round to 2 decimals (USDT)

    async def cleanup(self):
        """Cleanup resources."""
        if self.client:
            await self.client.close()
        self._connected = False


async def on_plan_event(ctx, topic: str, event):
    """Handle plan.ready events and execute trades with idempotency."""
    with tracer.start_as_current_span(
        "executor.on_plan_event",
        attributes={
            "event.topic": topic,
        },
    ) as span:
        try:
            # Parse plan
            payload = json.loads(event.payload.decode("utf-8"))

            symbol = payload.get("symbol", SYMBOL)
            action = payload.get("action", "HOLD")
            confidence = payload.get("confidence", 0.0)
            reasoning = payload.get("reasoning", "")
            plan_hash = payload.get("plan_hash")  # ðŸ†• Get plan_hash from planner

            print(f"\n[executor] ðŸ“‹ Received Plan:")
            print(f"[executor]    Symbol: {symbol}")
            print(f"[executor]    Action: {action}")
            print(f"[executor]    Confidence: {confidence:.2%}")
            print(f"[executor]    Reasoning: {reasoning}")
            if plan_hash:
                print(f"[executor]    Plan Hash: {plan_hash}")

            span.set_attribute("executor.plan.action", action)
            span.set_attribute("executor.plan.confidence", confidence)
            if plan_hash:
                span.set_attribute("executor.plan.plan_hash", plan_hash)

            # ðŸ†• Check if plan already executed (idempotency)
            if plan_hash:
                try:
                    is_executed, exec_info = await ctx.check_plan_executed(plan_hash)
                    if is_executed:
                        print(f"[executor] â­ï¸  SKIPPING: Plan already executed")
                        print(f"[executor]    Previous execution: {exec_info['action']} {exec_info['status']}")
                        print(f"[executor]    Order ID: {exec_info.get('order_id', 'N/A')}")
                        span.add_event("plan_already_executed", {
                            "previous_status": exec_info["status"],
                            "previous_order_id": exec_info.get("order_id", ""),
                        })
                        return  # Skip execution
                except Exception as e:
                    print(f"[executor] Failed to check execution status: {e}")
                    span.add_event("execution_check_failed", {"error": str(e)})

            # Execute plan
            global EXECUTOR_INSTANCE
            if not EXECUTOR_INSTANCE:
                print("[executor] ERROR: Executor not initialized")
                return

            result = await EXECUTOR_INSTANCE.execute_plan(payload)

            # ðŸ†• Mark plan as executed in Core Memory
            if plan_hash and result.get("status") != "error":
                try:
                    await ctx.mark_plan_executed(
                        plan_hash=plan_hash,
                        symbol=symbol,
                        action=action,
                        confidence=confidence,  # ðŸ”§ Added missing parameter
                        status=result["status"],
                        executed=result.get("executed", False),
                        order_id=result.get("order_id", ""),
                        order_size_usdt=result.get("order_size_usdt", 0.0),
                    )
                    print(f"[executor] âœ… Marked plan as executed in memory")
                    span.add_event("plan_marked_executed")
                except Exception as e:
                    print(f"[executor] Failed to mark execution: {e}")
                    span.add_event("mark_execution_failed", {"error": str(e)})

            # ðŸ†• Display execution statistics periodically
            try:
                stats = await ctx.get_execution_stats(symbol)
                total = stats.get("total_executions", 0)
                if total > 0 and total % 5 == 0:  # Every 5 executions
                    print(f"\n[executor] ðŸ“Š Execution Statistics for {symbol}:")
                    print(f"[executor]    Total Executions: {total}")
                    print(f"[executor]    Win Rate: {stats.get('win_rate', 0.0):.1%}")
                    print(f"[executor]    Recent Actions: {stats.get('recent_actions', [])}")
                    span.add_event("execution_stats", {
                        "total": total,
                        "win_rate": stats.get("win_rate", 0.0),
                    })
            except Exception as e:
                print(f"[executor] Failed to get execution stats: {e}")

            # Emit execution result
            await ctx.emit(
                f"execution.{symbol.lower()}",
                type="execution.complete",
                payload=json.dumps(result).encode("utf-8"),
            )

            print(f"[executor] ðŸ“¤ Emitted execution result: {result['status']}\n")

        except Exception as e:
            print(f"[executor] ERROR handling plan event: {e}")
            span.record_exception(e)
            import traceback
            traceback.print_exc()


async def main():
    """Main entry point."""
    _init_file_logger()
    try:
        _log("Executor Agent initializing...")
        # Load configuration
        config = load_project_config()
        agent_config = config.agents.get("executor-agent", {})
        _log(f"Loaded agent config: {json.dumps(agent_config)}")

        # Load runtime flags from config first
        enable_trading_flag = agent_config.get("enable_trading", False)

        # Load API credentials from environment
        api_key = os.getenv("OKX_API_KEY")
        secret_key = os.getenv("OKX_SECRET_KEY")
        passphrase = os.getenv("OKX_PASSPHRASE")
        use_demo = os.getenv("OKX_USE_DEMO", "true").lower() == "true"
        _log(f"Env OKX_USE_DEMO={use_demo}, enable_trading={enable_trading_flag}")

        # Only require credentials when trading is enabled
        if enable_trading_flag and not all([api_key, secret_key, passphrase]):
            _log("Missing OKX API credentials while trading is enabled")
            _log("Required: OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE")
            _log("Tip: create a .env file in the demo folder or export env vars before running")
            return

        # Create executor config
        executor_config = ExecutorConfig(
            api_key=api_key,
            secret_key=secret_key,
            passphrase=passphrase,
            use_demo=use_demo,
            min_order_usdt=agent_config.get("min_order_usdt", 10.0),
            max_order_usdt=agent_config.get("max_order_usdt", 50.0),
            enable_trading=enable_trading_flag,
        )

        _log("Executor Agent starting...")
        _log(f"Trading Mode: {'DEMO' if use_demo else 'PRODUCTION'}")
        _log(f"Trading Enabled: {executor_config.enable_trading}")
        _log(f"Order Size Range: {executor_config.min_order_usdt} - {executor_config.max_order_usdt} USDT")

        # Create agent
        agent = Agent(
            agent_id="executor-agent",
            topics=["plan.ready"],
            on_event=on_plan_event,
        )

        # Start agent first (connect to Core)
        await agent.start()
        _log("Connected to Loom Core")

        # Then initialize executor
        executor = TradeExecutor(executor_config)
        await executor.initialize()

        # Store executor globally for handler
        global EXECUTOR_INSTANCE
        EXECUTOR_INSTANCE = executor

        _log("Listening for trading plans on: plan.ready")
        _log("Will emit execution results to: execution.{symbol}")

        # Keep running
        try:
            await asyncio.Event().wait()
        except KeyboardInterrupt:
            _log("Shutting down...")
            await executor.cleanup()
            await agent.stop()

    except Exception as e:
        _log(f"FATAL ERROR: {type(e).__name__}: {e}")
        import traceback
        if _LOG_FH:
            traceback.print_exc(file=_LOG_FH)
        else:
            traceback.print_exc()
        raise


if __name__ == "__main__":
    asyncio.run(main())
