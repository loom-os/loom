"""Executor Agent - Trade Execution

Executes trading plans generated by the planner agent.
Connects to OKX via WebSocket for order placement.
"""

import asyncio
import json
import hmac
import base64
import time
import os
from datetime import datetime, timezone
from typing import Optional, Dict, Any
from dataclasses import dataclass

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False
    print("[executor] WARNING: aiohttp not available, WebSocket connection disabled")

from opentelemetry import trace
from loom import Agent, load_project_config

# Get tracer for business logic spans
tracer = trace.get_tracer(__name__)

# Default symbol
SYMBOL = "BTC"

# Global executor instance for event handler access
EXECUTOR_INSTANCE: Optional["TradeExecutor"] = None


# Simple file logger to capture early-exit issues under orchestrator
_LOG_FH = None

def _init_file_logger():
    global _LOG_FH
    try:
        base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        logs_dir = os.path.join(base_dir, "logs")
        os.makedirs(logs_dir, exist_ok=True)
        _LOG_FH = open(os.path.join(logs_dir, "executor-agent.log"), "a", buffering=1)
    except Exception:
        _LOG_FH = None


def _log(msg: str):
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{ts}] {msg}\n"
    try:
        print(f"[executor] {msg}")
    except Exception:
        pass
    if _LOG_FH:
        try:
            _LOG_FH.write(line)
        except Exception:
            pass


@dataclass
class ExecutorConfig:
    """Executor configuration."""

    api_key: str
    secret_key: str
    passphrase: str
    use_demo: bool = True
    min_order_size: float = 0.001  # Minimum order size in BTC
    max_order_size: float = 0.1    # Maximum order size in BTC
    enable_trading: bool = False   # Safety switch - must be explicitly enabled

    @property
    def ws_url(self) -> str:
        """Get WebSocket URL based on trading mode."""
        if self.use_demo:
            return "wss://wspap.okx.com:8443/ws/v5/private?brokerId=9999"
        else:
            return "wss://ws.okx.com:8443/ws/v5/private"


class OKXTradingClient:
    """OKX WebSocket client for trade execution."""

    def __init__(self, config: ExecutorConfig):
        self.config = config
        self.ws: Optional[aiohttp.ClientWebSocketResponse] = None
        self.session: Optional[aiohttp.ClientSession] = None
        self._authenticated = False
        self._request_id = 0
        self._pending_requests: Dict[str, asyncio.Future] = {}

    def _generate_signature(self, timestamp: str, method: str, request_path: str) -> str:
        """Generate OKX API signature."""
        message = timestamp + method + request_path
        mac = hmac.new(
            self.config.secret_key.encode('utf-8'),
            message.encode('utf-8'),
            digestmod='sha256'
        )
        return base64.b64encode(mac.digest()).decode('utf-8')

    async def connect(self) -> bool:
        """Connect to OKX WebSocket and authenticate."""
        if not AIOHTTP_AVAILABLE:
            print("[executor-okx] aiohttp not available")
            return False

        try:
            self.session = aiohttp.ClientSession()
            self.ws = await self.session.ws_connect(
                self.config.ws_url,
                timeout=aiohttp.ClientTimeout(total=30)
            )
            print(f"[executor-okx] WebSocket connected to {self.config.ws_url}")

            # Authenticate
            timestamp = str(int(datetime.now(timezone.utc).timestamp()))
            sign = self._generate_signature(timestamp, 'GET', '/users/self/verify')

            login_msg = {
                "op": "login",
                "args": [{
                    "apiKey": self.config.api_key,
                    "passphrase": self.config.passphrase,
                    "timestamp": timestamp,
                    "sign": sign
                }]
            }

            await self.ws.send_json(login_msg)

            # Wait for login response
            async for msg in self.ws:
                if msg.type == aiohttp.WSMsgType.TEXT:
                    data = json.loads(msg.data)
                    if data.get('event') == 'login':
                        if data.get('code') == '0':
                            self._authenticated = True
                            print("[executor-okx] Authentication successful")
                            # Start message handler
                            asyncio.create_task(self._message_handler())
                            return True
                        else:
                            print(f"[executor-okx] Authentication failed: {data.get('msg')}")
                            return False
                elif msg.type == aiohttp.WSMsgType.ERROR:
                    print(f"[executor-okx] WebSocket error during auth: {self.ws.exception()}")
                    return False

            return False

        except Exception as e:
            print(f"[executor-okx] Connection error: {e}")
            if self.session:
                await self.session.close()
            return False

    async def _message_handler(self):
        """Handle incoming WebSocket messages."""
        try:
            async for msg in self.ws:
                if msg.type == aiohttp.WSMsgType.TEXT:
                    data = json.loads(msg.data)

                    # Handle order responses
                    if data.get('op') == 'order':
                        request_id = data.get('id')
                        if request_id and request_id in self._pending_requests:
                            future = self._pending_requests.pop(request_id)
                            future.set_result(data)

                    # Handle error events
                    elif data.get('event') == 'error':
                        print(f"[executor-okx] Error event: {data.get('msg')}")
                        request_id = data.get('id')
                        if request_id and request_id in self._pending_requests:
                            future = self._pending_requests.pop(request_id)
                            future.set_exception(Exception(data.get('msg', 'Unknown error')))

                elif msg.type == aiohttp.WSMsgType.ERROR:
                    print(f"[executor-okx] WebSocket error: {self.ws.exception()}")
                    break

                elif msg.type == aiohttp.WSMsgType.CLOSED:
                    print("[executor-okx] WebSocket closed")
                    break

        except asyncio.CancelledError:
            print("[executor-okx] Message handler cancelled")
        except Exception as e:
            print(f"[executor-okx] Message handler error: {e}")

    async def place_market_order(
        self,
        inst_id: str,
        side: str,  # "buy" or "sell"
        size: float,
        trade_mode: str = "cash"  # "cash" for spot, "cross" for margin
    ) -> Dict[str, Any]:
        """Place a market order.

        Args:
            inst_id: Instrument ID (e.g., "BTC-USDT")
            side: "buy" or "sell"
            size: Order size (in base currency)
            trade_mode: Trading mode ("cash", "cross", "isolated")

        Returns:
            Order response dict
        """
        if not self._authenticated:
            raise Exception("Not authenticated")

        self._request_id += 1
        request_id = f"order_{self._request_id}"

        order_msg = {
            "id": request_id,
            "op": "order",
            "args": [{
                "instId": inst_id,
                "tdMode": trade_mode,
                "side": side.lower(),
                "ordType": "market",
                "sz": str(size),
            }]
        }

        # Create future for response
        future = asyncio.Future()
        self._pending_requests[request_id] = future

        # Send order
        await self.ws.send_json(order_msg)
        print(f"[executor-okx] Sent {side.upper()} order: {size} {inst_id}")

        try:
            # Wait for response (with timeout)
            response = await asyncio.wait_for(future, timeout=10.0)
            return response
        except asyncio.TimeoutError:
            self._pending_requests.pop(request_id, None)
            raise Exception("Order timeout")

    async def close(self):
        """Close WebSocket connection."""
        self._authenticated = False
        if self.ws:
            await self.ws.close()
        if self.session:
            await self.session.close()
        print("[executor-okx] WebSocket closed")


class TradeExecutor:
    """Trade execution engine."""

    def __init__(self, config: ExecutorConfig):
        self.config = config
        self.client: Optional[OKXTradingClient] = None
        self._connected = False

    async def initialize(self) -> bool:
        """Initialize trading client."""
        if not self.config.enable_trading:
            print("[executor] âš ï¸  Trading is DISABLED (safety switch)")
            print("[executor] Set enable_trading=true in config to enable")
            return False

        print("[executor] Initializing OKX trading client...")
        self.client = OKXTradingClient(self.config)
        self._connected = await self.client.connect()

        if self._connected:
            print("[executor] âœ… Trading client ready")
        else:
            print("[executor] âŒ Failed to connect to OKX")

        return self._connected

    async def execute_plan(self, plan: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a trading plan.

        Args:
            plan: Trading plan from planner agent

        Returns:
            Execution result
        """
        with tracer.start_as_current_span(
            "executor.execute_plan",
            attributes={
                "executor.symbol": plan.get("symbol", "unknown"),
                "executor.action": plan.get("action", "unknown"),
                "executor.confidence": plan.get("confidence", 0.0),
            },
        ) as span:
            action = plan.get("action", "HOLD")
            symbol = plan.get("symbol", SYMBOL)
            confidence = plan.get("confidence", 0.0)

            result = {
                "symbol": symbol,
                "plan_action": action,
                "plan_confidence": confidence,
                "executed": False,
                "execution_time_ms": int(time.time() * 1000),
            }

            # Check if trading is enabled
            if not self.config.enable_trading:
                result["status"] = "skipped"
                result["message"] = "Trading disabled (safety switch)"
                print(f"[executor] SIMULATED: {action} {symbol} (confidence: {confidence:.2%})")
                span.set_attribute("executor.status", "simulated")
                return result

            # Check if connected
            if not self._connected or not self.client:
                result["status"] = "error"
                result["message"] = "Not connected to exchange"
                print(f"[executor] ERROR: Not connected to OKX")
                span.set_attribute("executor.status", "error")
                return result

            # Execute based on action
            try:
                if action == "HOLD":
                    result["status"] = "hold"
                    result["message"] = "No action required"
                    print(f"[executor] HOLD {symbol} - No action")
                    span.set_attribute("executor.status", "hold")

                elif action in ["BUY", "SELL"]:
                    # Calculate order size based on confidence
                    # Higher confidence = larger position size
                    order_size = self._calculate_order_size(confidence)

                    inst_id = f"{symbol}-USDT"
                    side = "buy" if action == "BUY" else "sell"

                    # Place order
                    order_response = await self.client.place_market_order(
                        inst_id=inst_id,
                        side=side,
                        size=order_size,
                        trade_mode="cash"  # Spot trading
                    )

                    # Parse response
                    if order_response.get("code") == "0":
                        order_data = order_response.get("data", [{}])[0]
                        result["executed"] = True
                        result["status"] = "success"
                        result["order_id"] = order_data.get("ordId")
                        result["order_size"] = order_size
                        result["message"] = f"Order placed: {side.upper()} {order_size} {inst_id}"

                        print(f"[executor] âœ… EXECUTED: {side.upper()} {order_size} {inst_id}")
                        print(f"[executor]    Order ID: {result['order_id']}")

                        span.set_attribute("executor.status", "success")
                        span.set_attribute("executor.order_id", result["order_id"])
                        span.set_attribute("executor.order_size", order_size)
                    else:
                        result["status"] = "error"
                        result["message"] = order_response.get("msg", "Order failed")
                        print(f"[executor] âŒ ORDER FAILED: {result['message']}")
                        span.set_attribute("executor.status", "error")

                else:
                    result["status"] = "error"
                    result["message"] = f"Unknown action: {action}"
                    span.set_attribute("executor.status", "error")

            except Exception as e:
                result["status"] = "error"
                result["message"] = str(e)
                print(f"[executor] âŒ EXECUTION ERROR: {e}")
                span.set_attribute("executor.status", "error")
                span.record_exception(e)

            return result

    def _calculate_order_size(self, confidence: float) -> float:
        """Calculate order size based on confidence level.

        Higher confidence = larger position size (within limits).
        """
        # Scale order size: 50% confidence = min size, 100% confidence = max size
        size_range = self.config.max_order_size - self.config.min_order_size
        confidence_factor = max(0.0, min(1.0, (confidence - 0.5) * 2))  # Map 0.5-1.0 to 0-1

        order_size = self.config.min_order_size + (size_range * confidence_factor)
        return round(order_size, 6)  # Round to 6 decimals

    async def cleanup(self):
        """Cleanup resources."""
        if self.client:
            await self.client.close()
        self._connected = False


async def on_plan_event(ctx, topic: str, event):
    """Handle plan.ready events and execute trades."""
    with tracer.start_as_current_span(
        "executor.on_plan_event",
        attributes={
            "event.topic": topic,
        },
    ) as span:
        try:
            # Parse plan
            payload = json.loads(event.payload.decode("utf-8"))

            symbol = payload.get("symbol", SYMBOL)
            action = payload.get("action", "HOLD")
            confidence = payload.get("confidence", 0.0)
            reasoning = payload.get("reasoning", "")

            print(f"\n[executor] ðŸ“‹ Received Plan:")
            print(f"[executor]    Symbol: {symbol}")
            print(f"[executor]    Action: {action}")
            print(f"[executor]    Confidence: {confidence:.2%}")
            print(f"[executor]    Reasoning: {reasoning}")

            span.set_attribute("executor.plan.action", action)
            span.set_attribute("executor.plan.confidence", confidence)

            # Execute plan
            global EXECUTOR_INSTANCE
            if not EXECUTOR_INSTANCE:
                print("[executor] ERROR: Executor not initialized")
                return

            result = await EXECUTOR_INSTANCE.execute_plan(payload)

            # Emit execution result
            await ctx.emit(
                f"execution.{symbol.lower()}",
                type="execution.complete",
                payload=json.dumps(result).encode("utf-8"),
            )

            print(f"[executor] ðŸ“¤ Emitted execution result: {result['status']}\n")

        except Exception as e:
            print(f"[executor] ERROR handling plan event: {e}")
            span.record_exception(e)
            import traceback
            traceback.print_exc()


async def main():
    """Main entry point."""
    _init_file_logger()
    try:
        _log("Executor Agent initializing...")
        # Load configuration
        config = load_project_config()
        agent_config = config.agents.get("executor-agent", {})
        _log(f"Loaded agent config: {json.dumps(agent_config)}")

        # Load runtime flags from config first
        enable_trading_flag = agent_config.get("enable_trading", False)

        # Load API credentials from environment
        api_key = os.getenv("OKX_API_KEY")
        secret_key = os.getenv("OKX_SECRET_KEY")
        passphrase = os.getenv("OKX_PASSPHRASE")
        use_demo = os.getenv("OKX_USE_DEMO", "true").lower() == "true"
        _log(f"Env OKX_USE_DEMO={use_demo}, enable_trading={enable_trading_flag}")

        # Only require credentials when trading is enabled
        if enable_trading_flag and not all([api_key, secret_key, passphrase]):
            _log("Missing OKX API credentials while trading is enabled")
            _log("Required: OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE")
            _log("Tip: create a .env file in the demo folder or export env vars before running")
            return

        # Create executor config
        executor_config = ExecutorConfig(
            api_key=api_key,
            secret_key=secret_key,
            passphrase=passphrase,
            use_demo=use_demo,
            min_order_size=agent_config.get("min_order_size", 0.001),
            max_order_size=agent_config.get("max_order_size", 0.01),
            enable_trading=enable_trading_flag,
        )

        _log("Executor Agent starting...")
        _log(f"Trading Mode: {'DEMO' if use_demo else 'PRODUCTION'}")
        _log(f"Trading Enabled: {executor_config.enable_trading}")
        _log(f"Order Size Range: {executor_config.min_order_size} - {executor_config.max_order_size} BTC")

        # Create agent
        agent = Agent(
            agent_id="executor-agent",
            topics=["plan.ready"],
            on_event=on_plan_event,
        )

        # Start agent first (connect to Core)
        await agent.start()
        _log("Connected to Loom Core")

        # Then initialize executor
        executor = TradeExecutor(executor_config)
        await executor.initialize()

        # Store executor globally for handler
        global EXECUTOR_INSTANCE
        EXECUTOR_INSTANCE = executor

        _log("Listening for trading plans on: plan.ready")
        _log("Will emit execution results to: execution.{symbol}")

        # Keep running
        try:
            await asyncio.Event().wait()
        except KeyboardInterrupt:
            _log("Shutting down...")
            await executor.cleanup()
            await agent.stop()

    except Exception as e:
        _log(f"FATAL ERROR: {type(e).__name__}: {e}")
        import traceback
        if _LOG_FH:
            traceback.print_exc(file=_LOG_FH)
        else:
            traceback.print_exc()
        raise


if __name__ == "__main__":
    asyncio.run(main())
